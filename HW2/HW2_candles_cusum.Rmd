---
title: "Построение свечей. CUSUM фильтр."
author: "PFL Advisors, Алгоритмический деск."
date: "27 11 2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(eval = FALSE)
```

```{r, message=FALSE}
library(readr)
library(dplyr)
library(ggplot2)
library(lubridate)
library(car) # для Q-Q графика с доверительными интервалами
```

Загрузим файл с тиковыми данными 

```{r, message=FALSE}
ticks <- read_csv('ETHUSDT_2021-10_small.rds')
ticks
```

**Примечание**:
**tibble** - более строгий с точки зрения типизации аналог dataframe, представленный
в семействе пакетов для работы с данными tidyverse,
инструментами которых мы и будем сегодня пользоваться.

Займемся структуризацией сырых тиковых данных.

## Часть 1. Классические свечи, свечи с фиксированным числом тиков, свечи на основе объемов и денежной массы

### Классические свечи

Реализуйте вспомогательную функцию, группирующую данные по номеру свечи и вычисляющую для
каждой из свечей: время открытия, время закрытия, OHLC, объем.
(см. функционал пакета dplyr: **group_by**, **summarise**)

```{r}
summarise_by_candle_id <- function(data, candle_id) {
  # TODO
  return(candles)
}
```

Будем считать, что каждая свеча начинается в кратный заданному периоду (например, 15 минут)
момент времени.
Воспользуемся функцией **floor_date** пакета lubridate для того, что привести дату каждого тика
к времени начала соответствующей свечи.

(В качестве параметра period подразумевается объект из lubridate. Пример: period(15, 'minute'))

```{r}
get_classic_candles <- function(data, period) {
  
  candle_start_time <- lubridate::floor_date(data$time, period)
  
  candles <- summarise_by_candle_id(data, candle_start_time)
  return(candles)
}
```

```{r}
classic_candles <- get_classic_candles(ticks, period(5, 'minute'))
class_candles
```


Такой способ организации свечей через фиксированные интервалы времени - самый используемый на
практике. Он интуитивен для трейдера, но имеет недостатки, возникающие при попытке анализа данных.
Торговля в среднем идет активнее в одни часы, чем в другие (например, сразу после открытия)
и во многом связана с ритмом жизни людей.
Таким образом, информация о ценах на бирже - неоднородна во времени (гетероскедастична),
что не удовлетворяет предпосылкам многих статистических моделей.
Попробуем исправить этот недостаток и заодно улучшить некоторые статистические свойства наших
свечей, в том числе приблизив доходности к нормальному распределению.


### Cвечи с фиксированным числом сделок

Первым нашим изменением будет организация свечей через определенное число тиков. Это позволит
учесть неравномерность поступления информации во времени.

```{r}
get_tick_candles <- function(data, candle_length) {
  # Получите вектор длины nrow(data), ставящий в соответствие номер свечи каждому наблюдению
  # из данных. Каждая свеча, кроме последней, должна быть длины candle_length.
  candle_number <- # TODO
  
  candles <- summarise_by_candle_id(data, candle_number)
  return(candles)
}
```

```{r}
tick_candles <- get_tick_candles(ticks, 268)
tick_candles
```

Несмотря на однородность сделок по времени, у этого способа тоже есть свой недостаток.
Мы не отличали друг от друга тики с большими объемами и тики с маленькими объемами,
что может привести к наличию свечей из одних только сделок с очень маленькими объемами,
наравне со свечами с активной торговлей большими объемами, тогда как последние несут в себе
значительно больше информации, чем первые.

### Свечи с фиксированным объемом

Попробуем исправить описанную выше проблему и учесть объемы. Будем переходить к новой свече,
когда было сторговано предварительно заданное количество активов (threshold).

Для этого нам надо посчитать кумулятивную сумму объемов.
В первом задании нам уже встречалась
векторная функция cumsum(), но здесь она не подойдет, так как мы хотим сбрасывать сумму каждый
раз при достижении указанного порога threshold.

Реализуйте функцию, вычисляющую кумулятивную сумму входного вектора.<br />
Следующее значение после превышения порога модулем накопленной суммы должно быть равно
соответствующему элементу суммируемого вектора
(если `cumsum_threshold(x, t)[i] >= threshold`, то `cumsum_threshold(x, t)[i + 1] = x[i + 1]`).<br />

**Пример работы**:<br />
`> cumsum_threshold(c(3, 6, 9, 3, 9, 6), 10)`<br />
`[1] 3 9 18 3 12 6`<br />

Не пользуйтесь циклом и напишите решение в функциональном стиле.<br />
Вам помогут функции **accumulate** из пакета purrr и **if_else** из dplyr.<br />

```{r}
cumsum_threshold <- function(data, threshold) {
  # TODO
  return(accumulated_value)
}
```

Так как далее мы будем и дальше расширять идею создания свечей при достижении порога
определенной величиной, то создадим общую для этого подхода функцию:

```{r}
get_candles_by_accumulated_value <- function(data, accumulated_value, threshold) {

  # Получим логический вектор, значениям TRUE которого соотвествуют те тики, в которые накопленная
  # величина не меньше порога.
  candle_start <- # TODO
  
  # Далее установим соответствия между каждым тиком и номером его свечи.
  # Получите вектор чисел, начиная с 0, возрастающий на единицу в индексах, где candle_start TRUE
  # (пользуйтесь неявным приведением логического вектора к числовому)
  candle_number <- # TODO
  
  # ВАЖНО:
  # На данный момент тик, достигший порога объема, попадает в начало новой свечи. Иначе говоря,
  # мы завершаем свечи до получения информации о достижении порогового значения,
  # что не соответствует действительности и может исказить наши результаты.
  
  # Исправим ситуацию:
  candle_number <- dplyr::lag(candle_number)
  candle_number[1] <- 0
  
  candles <- summarise_by_candle_id(data, candle_number)
  return(candles)
}
```

Воспользуемся реализованными функциями для создания свечей по объемам:

```{r}
get_volume_candles <- function(data, threshold) {
  # TODO
  candles <- get_candles_by_accumulated_value(data, accumulated_volume, threshold)
  return(candles)
}
```

```{r}
volume_candles <- get_volume_candles(ticks, 29700)
volume_candles
```


### Cвечи с фиксированной денежной массой

Попробуем внести в наш алгоритм еще одно улучшение, чтобы учесть еще больше доступной
рыночной информации.
Свечи на основе объемов не учитывают цену исследуемого инструмента. При исследовании длинной
торговой истории, в силу изменения порядка цен, обмены одними и теми же объемами бумаг
на разных временных интервалах соответствуют различной рыночной стоимости. Мы же хотим,
чтобы наши наблюдения имели одинаковую ценность и при этом были однородны с точки зрения
содержания рыночной информации.
Для этого воспользуемся в точности предыдущим алгоритмом, но вместо объемов будем
накапливать сторгованную денежную массу.

```{r}
get_dollar_candles <- function(data, threshold) {
  # TODO
  candles <- get_candles_by_accumulated_value(data, accumulated_money, threshold)
  return(candles)
}
```

```{r}
dollar_candles <- get_dollar_candles(ticks, 5340000)
dollar_candles
```


Теперь, после подготовки функций для создания различных свечей, перейдем к их построению
и сравним их свойства.


### Сравнение свойств

**Примечание:**
Константы, использованные при создании свечей, были подобраны так,
чтобы получилось примерно столько же свечей, сколько классических 5-ти минутных.

Построим графики квантиль-квантиль для приращений цен закрытия наших свечей:

```{r}
car::qqPlot(diff(classic_candles$close))
car::qqPlot(diff(tick_candles$close))
car::qqPlot(diff(volume_candles$close))
car::qqPlot(diff(dollar_candles$close))
```

Визуальная оценка графиков квантиль-квантиль позволяет заключить, что квантили доходностей
свечей на основе тиков, объемов и денежной массы ближе к квантилям нормального распределения,
чем квантили доходностей классических свечек. Разница между тремя способами незначительна.
Но несмотря на заметное улучшение, мы все также наблюдаем тяжелые хвосты.

## Часть 2. Свечи на основе дисбаланса между покупкой и продажей

### Свечи по дисбалансу тиков

Попробуем реализовать другой подход, использующий еще больше информации о рынке.

Алгоритм состоит в том, что мы строим свечи на основе накопленной разницы
между числом покупателей и продавцов за период с начала свечи.
Переход к новой свече происходит при превышении модулем этой разности определенного порога.

Данный алгоритм позволяет получить больше свечек в моменты повышенной активности одной
из подавляющих сторон и меньше, когда спрос и предложение сбалансированы.
Наша мотивация заключается в том, что сильное преобладание одной из сторон означает
наличие крупных игроков, информированных трейдеров или важных событий для рынка.
Тогда для построения алгоритмов и поиска закономерностей полезно иметь большую частоту данных
именно в такие периоды активности, чем в периоды относительного спокойствия.

#### Дополним тиковые данные сторонами сделок

Положительное изменение цены означает покупку, отрицательное - продажу.
Отсутствие изменения цены в данном тике означает, что на данном уровне цены поглощен
еще не весь предложенный/запрошенный по данной цене объем актива.
Таких тиков может быть несколько подряд: до тех пор, пока цена не пробьет новый уровень,
либо до изменения направления сделки, когда цена изменится из-за спрэда между бидом и аском.
Таким образом, направление сделки, в которой цена не изменилась, совпадает с направлением
предыдущей сделки, в которой произошло изменение цены.

Для лучшего понимания устройства сделок можно ознакомится с биржевым стаканом и типами ордеров.
Например, в этом блоге, есть достаточно наглядное описание:
https://www.tradientblog.com/2020/03/understanding-the-limit-order-book/

Сначала найдем изменение цены для каждого тика:
```{r}
price_delta <- c(NA, diff(ticks$price))
```
**Примечание**:
Функция diff стандартного пакета base убирает возникающую при вычислении разниц
недостающую величину из начала массива (несколько, если окно разницы больше 1).
Но так как далее мы хотим присоединить полученные результаты к исходному датафрейму,
то для соответствия числа строк датафрейма длине нашего вектора приходится присоединить
эту недостающую величину обратно в начало.

Для того, чтобы заполнить стороны тиков, в которых цена не менялась, воспользуемся функцией
na.locf() пакета zoo, интерполирующией все NA предыдущим non-NA значением:

```{r}
tick_side <- sign(price_delta)
tick_side[tick_side == 0] = NA
tick_side <- zoo::na.locf(tick_side, na.rm = FALSE)
# Примечание:
# Используем в na.locf() параметр na.rm = FALSE для того,
# чтобы не удалять недостающие значения в начале.
# (мы не знаем направление этих сделок и их нечем интерполировать)
```

```{r}
ticks[, 'side'] <- tick_side
# Избавимся от первых тиков, для которых не смогли определить стороны сделок:
ticks <- na.omit(ticks)
```

### Свечи на основе дисбаланса сторон сделок

Реализуйте функцию для построения свечей по дисбалансу сторон сделок.
Реализация аналогична предыдущим функциям, строившим свечи на основе объемов и денежной массы.
Для корректного сравнения с пороговым значением нужно учесть,
что накопленная сторона тиков может быть произвольного знака и использовать модуль.

```{r}
get_tick_imbalance_candles <- function(data, threshold) {
  # TODO
  candles <- get_candles_by_accumulated_value(data, tick_imbalance, threshold)
  return(candles)
}
```

### Свечи на основе дисбаланса объемов и денежной массы

Обобщим предыдущий алгоритм, дополнив информацией не только о сторонах сделок, но и
торгуемых объемах и ценах, аналогично тому, как мы делали раньше.

Реализуйте две соответствующие функции, взяв за основу **get_tick_imbalance_candles** и
правильно подобрав накапливаемые величины.

Свечи на основе дисбаланса сторгованного объема:
```{r}
get_volume_imbalance_candles <- function(data, threshold) {
  # TODO
  candles <- get_candles_by_accumulated_value(data, volume_imbalance, threshold)
  return(candles)
}
```

Свечи на основе дисбаланса сторгованной денежной массы:
```{r}
get_dollar_imbalance_candles <- function(data, threshold) {
  # TODO
  candles <- get_candles_by_accumulated_value(data, dollar_imbalance, threshold)
  return(candles)
}
```

Подведем итоги.

Мы рассмотрели несколько упрощенный вариант построения свечей, сравнивая накопленную величину
дисбаланса с константой. При этом на практике, вследствие постоянно изменяющейся ситуации на
рынке и, например, достаточно длинных периодов гонки/рецессии можно было бы еще улучшить подход
и сравнивать накопленную величину дисбаланса с некоторым ожидаемым значением,
зависящим от времени, прошедшего с начала свечи.<br />
Для дополнительной информации см.: Prado, Advances in Financial ML, стр. 29 - 31.

## Часть 3. Фильтрация событий, CUSUM фильтр

Следующим этапом после организации данных в свечи может выступить фильтрация событий.
Мотивация состоит в том, что финансовые данные в среднем имеют достаточно низкое отношение
сигнал/шум, что критично для построения признаков и обучения алгоритмов.
Попробуем адресовать эту проблему, извлекая только "релевантные" для нас наблюдения.
Например, это могут быть наблюдения непосредственно после макроэкономических событий,
структурных переломов, скачков волатильности. Анализируя данные на таких подвыборках,
мы можем добиться большей точности предсказаний.

В качестве примера рассмотрим CUSUM фильтр.
см. Prado, Advances in Financial ML, стр. 38 - 40

Реализуйте функцию для CUSUM фильтра.
Также как и с **cumsum_threshold** постарайтесь написать ее в функциональном стиле.

```{r}
# input - вектор значений
# index - вектор дат, соответствующих значениям из input
# threshold - пороговое значение
cusum_filter <- function(input, index, threshold) {
  # TODO
  return(events)
}
```

Применим фильтр к приращениям цен закрытия наших свечей:

```{r}
filter_candles <- function(candles, threshold) {
  target <- diff(candles$close)
  index <- candles$start
  
  filtered_index <- cusum_filter(target, index[-1], threshold)
  filtered_candles <- candles[index %in% filtered_index, ]
  
  return(filtered_candles)
}
```

Воспользуемся предварительно посчитанными свечами:

```{r}
candles <- dollar_candles
filtered_candles <- filter_candles(candles, 3)
```

Визуализируем результаты работы фильтра:

```{r}
ggplot() +
  geom_line(data = candles, aes(x = start, y = close)) +
  geom_point(data = filtered_candles, aes(x = start, y = close), color = 'salmon')
```
